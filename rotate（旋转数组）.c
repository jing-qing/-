目的：练习算法
内容：leetcode初级算法第三题《旋转数组》
日期：2021.2.21

题目内容：
给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。

 

进阶：

尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。
你可以使用空间复杂度为 O(1) 的 原地 算法解决这个问题吗？
 

示例 1:

输入: nums = [1,2,3,4,5,6,7], k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右旋转 1 步: [7,1,2,3,4,5,6]
向右旋转 2 步: [6,7,1,2,3,4,5]
向右旋转 3 步: [5,6,7,1,2,3,4]
示例 2:

输入：nums = [-1,-100,3,99], k = 2
输出：[3,99,-1,-100]
解释: 
向右旋转 1 步: [99,-1,-100,3]
向右旋转 2 步: [3,99,-1,-100]

 经过我的思考一共做出两种算法，如下：

 算法一：
 void rotate(int* nums, int numsSize, int k)
{
    int t=nums[numsSize-1],i,j,m;

    for(j=0;j<k;j++)
    {
        for(i=0;i<numsSize;i++)
        {
            m=nums[i];
            nums[i]=t;
            t=m;          
        }              
        t=nums[numsSize-1];
    }
}
执行用时：460 ms, 在所有 C 提交中击败了7.22%的用户
内存消耗：7.4 MB, 在所有 C 提交中击败了82.72%的用户

    这种算法的思想是先通过一个内层for循环实现将数组往后移动一位（最后一位移到第一位），在执行外层循环重复内层for循环k次，这样就达到了最终
目的。但是这种方法优点是极容易想到并编写，缺点也很明显就是执行时间长，如果数组长度比较长且k的值也比较大的情况下耗得时间将会大大增加，并不
是一种很好的算法。

算法二：
int f(int k,int numsSize)
{
    int i;
    for(i=1;i<=numsSize;i++)
    {
        if((k*i)%numsSize==0)
        break;
    }
    if(i==numsSize)
    return 1;
    else
    return i;
}

void rotate(int* nums, int numsSize, int k)
{
    int i,m=nums[0],t,j,a;
    int* p;
    p=nums;
 
    if(k>numsSize&&(k%numsSize!=0))
    {
        for(;k>numsSize;)
        k=k-numsSize;
    }
    if(numsSize>1)
    {
    if(k>1&&f(k,numsSize)==1)
    {
        for(i=0;i<numsSize;i++)
        {
            if((p+k)<=&nums[numsSize-1])
        {
            t=*(p+k);
            *(p+k)=m;
            m=t;
            p=p+k;
        }
        else
        {
            t=*(p-numsSize+k);
            *(p-numsSize+k)=m;
            m=t;
            p=p-numsSize+k;
        }
        }
    }
    if(k!=0&&numsSize%k==0)
    {
        for(j=0;j<k;j++)
        {
            p=&nums[j];
            m=nums[j];
            for(i=0;i<numsSize/k;i++)
        {
            if((p+k)<=&nums[numsSize-1])
        {
            t=*(p+k);
            *(p+k)=m;
            m=t;
            p=p+k;
        }
        else
        {
            t=*(p-numsSize+k);
            *(p-numsSize+k)=m;
            m=t;
            p=p-numsSize+k;
        }
        }
        }
    }
    if(2*k>numsSize&&f(k,numsSize)>1)
    {
        a=f(k,numsSize);
        for(j=0;j<numsSize/a;j++)
        {
            p=&nums[j];
            m=nums[j];
            for(i=0;i<a;i++)
        {
            if((p+k)<=&nums[numsSize-1])
        {
            t=*(p+k);
            *(p+k)=m;
            m=t;
            p=p+k;
        }
        else
        {
            t=*(p-numsSize+k);
            *(p-numsSize+k)=m;
            m=t;
            p=p-numsSize+k;
        }
        }
        }
    }
    }
}
执行用时：16 ms, 在所有 C 提交中击败了92.71%的用户
内存消耗：7.3 MB， 在所有 C 提交中击败了97.83%的用户

    该算法相比于第一种无论是在用时还是内存方面都有了极大的飞跃。这个算法运用了指针，加快了运算速度，但是代码内容特别长，他人不易
理解。该算法是从第一数组元素开始直接移动到相应的位置并从该位置开始将原本该位置元素移到相应位置如此循环，直至全部元素。
例如：数组长度为10，k为3。
数组：1，2，3，4，5，6，7，8，9，10。k=3，则需要将1移到4的位置，在将4移到7的位置，以此类推经过10次每个元素都到了相应的位置。但是
如果k=2的话，则从1开始经过5次重新回到1了，则 2，4，6等5个元素位置不会发生变化，同理数组长度为6，k=4经过3次同样会形成一个循环。
    因此，经过分析，主要分成了三类境况讨论。首先编写了一个函数f，该函数作用是判断k和数组长度的最小公倍数是否是他们乘积，若是则返回1，
若不是则返回能整除数组长度的k的最小整数倍数。然后经过分析若k大于数组长度，则先经过一个循环，让k减数组长度直到小于数组长度为止。在考虑
数组元素大于1，因为数组元素为1则无需旋转，k=0或者k恰好是数组长度的整数倍也无需旋转，因为旋转结果与原数组一致。在此基础下讨论三种情况，
第一种函数f返回值等于1同时k也大于1（加上k大于1的原因是k=1的时候函数f返回值确实是1，但是恰好也满足下述第二种情况，相当于会重复操作一次
于是加上k>1的条件）；第二种情况是数组长度能将k整除，因为该情况下每numsSize/k个元素形成一个循环，这样其他元素的位置不会发生变化；第三种
情况是函数f返回值不是1，且2k>numsSize（若不加上该条件会导致部分情况满足第三种的同时满足第二种），这样部分元素也会形成循环。在介绍该算法
基本的代码
if((p+k)<=&nums[numsSize-1])
    {
        t=*(p+k);
        *(p+k)=m;
        m=t;
        p=p+k;
        }
    else
    {
        t=*(p-numsSize+k);
        *(p-numsSize+k)=m;
        m=t;
        p=p-numsSize+k;
    }
    }
该部分代码作用主要是是启到换位的作用。
总结：算法二内容众多，建议反复思考，这里只是分析最基本的思想，精髓还需多多体会，其思想只可意会不可言传。
